#Паттерны
#Higher-Order Component

#HOC  — функция, которая принимает компонент как аргумент и возвращает новый компонент (функцию или класс) с измененным (расширенным) функционалом.
- Применяется когда нужно использовать повторяющуюся логику, применяемую к ряду компонентов, тем самым дополнив их функционал.
- HOC должен быть чистой функцией без побочных эффектов.
- HOC нельзя использовать в методе render(). Композиция должна быть статической, то есть во время экспорта компонента.


#Render Prop
Как и HOC, позволяет реализовать повторное использование логики. В большинстве случаев эти паттерны взаимозаменяемы. Плюс это отсутствие сайд-эффектов в обёрнутом компоненте. Минус это читабельность кода при использовании нескольких оберток в одном копоненте. Проблема читабельности в некоторой степени решается такими библиотеками как react-adopt.

Идея использования паттерна заключается в передаче управления рендером другому компоненту, а сам Render Prop отвечает только за состояние и его обновление. Для этого в проп children передается функция.

Материалы
https://www.youtube.com/watch?v=0BNgi9vofaw&ab_channel=WixEngineeringTechTalks
https://react-fns.netlify.app/en/
https://github.com/acdlite/recompose


#Context API
Данные передаются сверху вниз через пропсы, но это может быть неудобно для определенных типов данных (глобальных), которые требуются многим компонентам на разных уровнях в приложении (локализация, тема оформления, состояние авторизации и др.).
Контекст обеспечивает способ передачи данных глубоко по дереву компонентов без необходимости явно передавать пропсы в промежуточные компоненты вручную на каждом уровне.

 #React.createContext()
 const Context = React.createContext(defaultValue);
- Создает объект контекста содержащий пару компонентов: <Context.Provider> (поставщик) и <Context.Consumer> (потребитель).
- При рендере, потребитель прочитает текущее значение контекста из ближайшего соответствующего поставщика выше в дереве компонентов.
- Аргумент defaultValue используется потребителем, если у него нет соответствующего поставщика над ним в дереве.

#Provider
Компонент, позволяющий потребителям подписываться на изменения контекста. Используется для создания и передачи контекста.
<MyProvider value={/* value */}>
- Принимает проп value - значение контекста, которое будет передано потомкам-потребителям этого контекста.
- Позволяет потребителям подписываться на изменения контекста независмо от глубины вложености.
- Один провайдер может быть связан со многими потребителями.
- Провайдеры могут быть вложены друг в друга.

#Consumer
Компонент, который подписывается на изменения контекста. Получает текущий контекст из ближайшего сопоставимого <Provider> выше в дереве.
<Consumer>
  {context => {
    /* Возвращает JSX-разметку */
  }}
</Consumer>

Релизован по патерну Render Prop, поэтому ожидает функцию в качестве дочернего элемента.
Параметр context, будет содержать значение контекста ближайшего провайдера для этого контекста выше в дереве.
Если для этого контекста нет провайдера, аргумент context будет содержать значение по умолчанию, которое было передано в React.createContext().
Все потребители, являющиеся потомками провайдера, будут ре-рендериться всякий раз, когда изменяется значение контекста (пропа value).
Потребитель обновляется даже тогда, когда компонент-предок выше в дереве отказался ре-рендериваться используя shouldComponentUpdate().