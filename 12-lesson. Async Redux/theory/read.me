# Middleware (прослойка) - общая концепция в программном обеспечении, инструмент для расширения функционала, находящийся между двух точек в логической цепочке исполнения кода.

Прослойка это функция промежуточной обработки, которая получает некие данные, может их обработать и, если необходимо, передать дальше по цепочке. Можно использовать множество прослоек в одном проекте.

Redux-прослойки предоставляют точку расширения между отправкой действия и моментом, когда это действие достигает редюсера. Прослойки используются для логирования, сообщения об ошибках, обработки HTTP-запросов, аналитики и т.д.


-Перед тем как дейсвия попадают в редюсеры, они проходят через цепочку (стек) прослоек.
-Прослойки получают доступ ко всем действиям.
-Если прослойка рассчитана на работу с каким-то действием, она может его изменять, отменять или выполнять какие-то другие дейтсвия.
-Если прослойка не рассчитана на работу с определенным типом действий, она просто пропускает действие через себя без изменений.
-После того как действие прошло всю цепочку прослоек, оно попадает в редюсеры.


#Cоздание прослоек
const middleware = store => next => action => {}; (тут используется карирование)

 * store - ссылка на Redux-хранилище
 * action - текущее действие
*  next - функция которую необходимо вызвать когда прослойка закончила обработку действия, для того чтобы отправить его дальше по цепочке прослоек или в редюсеры.

Для того чтобы использовать прослойку необходимо добавить ее при создании хранилища. Для этого у Redux есть функция applyMiddleware, которая принимает произвольное количество аргументов. Результат ее вызова мы передаем как аргумент enhancer в createStore().

Карирование
- http://prgssr.ru/development/vvedenie-v-karrirovanie-v-javascript.html



#Асинхронность в Redux
Асинхронные действия
Redux не предоставляет функционала для отправки асинхронных действий, эту задачу решают прослойки. Есть много готовых решений: для простых асинхронных операций подойдет redux-promise, для средней сложности redux-thunk, а для очень сложных и запутанных redux-saga или redux-observable.

Для начала необходимо научиться писать асинхронные action creators. Это функции которые вместо объекта-действия возвращают функцию. В компьютерных науках это называется thunk.

const asyncActionCreator = args => dispatch => {};

Когда action creator возвращает функцию, эта функция будет выполняться прослойкой. Такая функция не должна быть чистой, поэтому она может иметь побочные эффекты, в том числе выполнение асинхронных HTTP-запросов. В ее теле также могут быть отправлены другие сихронные действия.


#thunk middleware
Напишем прослойку thunk, которая умеет обрабатывать асинхронные действия. Если действие это функция, она будет вызвана и аргументами ей будут переданы dispatch и getState, тем самым позволяя использовать dispatch в теле действия. В противном случае, если это обычный объект, действие будет отправлено дальше по цепочке прослоек.

const thunk = ({ dispatch, getState }) => next => action =>
  typeof action === 'function' ? action(dispatch, getState) : next(action);

Репозиторий redux-thunk
  - https://github.com/reduxjs/redux-thunk



#HTTP-запросы

При асинхроннах операциях зачастую необходимо отображать лоадеры и обрабатывать ошибки. В таких случаях можно использовать следующую схему действий.

Начальное состояние может выглядеть так, с полями флага загрузки и хранения ошибки.

{
  notes: {
    items: [],
    loading: false,
    error: null
  }
}


Тогда асинхронное действие может выглядеть так.

При notes/FETCH_START в поле loading записывается true, а при notes/FETCH_SUCCESS или notes/FETCH_FAILURE наоборот false
При notes/FETCH_FAILURE в поле error записывается объект ошибки
При notes/FETCH_SUCCESS в поле items записываются данные
const fetchStart = () => ({
  type: 'notes/FETCH_START',
});

const fetchSuccess = data => ({
  type: 'notes/FETCH_SUCCESS',
  payload: data,
});

const fetchFailure = error => ({
  type: 'notes/FETCH_FAILURE',
  payload: error,
});

const asyncActionCreator = args => dispatch => {
  dispatch(fetchStart());

  fetch('some url')
    .then(r => r.json())
    .then(data => dispatch(fetchSuccess(data)))
    .catch(err => dispatch(fetchFailure(err)));
};





Доп материалы
youtube.com/watch?v=xihoZZU0gao&feature=youtu.be&ab_channel=ReactCasts
https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60